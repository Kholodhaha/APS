# Лабораторная работа 6 "Тракт данных"

Микроархитектуру можно разделить на две части: тракт данных и устройство управления. По тракту данных перемещаются данные (из памяти инструкций, регистрового файла, АЛУ, памяти данных, мультиплексоров), а устройство управления (основной дешифратор команд) получает текущую инструкцию из тракта и в ответ говорит ему как именно выполнить эту инструкцию, то есть управляет тем, как эти данные будут через тракт данных проходить.

## Цель

Описать на языке **Verilog** процессор с архитектурой **RISC-V**, реализовав его тракт данных, использую ранее разработанные блоки, и подключив к нему устройство управления. В рамках этого трека лабораторных работ требуется реализовать только поддержку обработки слов (то есть БЕЗ инструкций связанных с байтами и полусловами: `lh`, `lhu`, `lb`, `lbu`, `sh`, `sb`).

## Ход работы

1. Изучить микроархитектурную реализацию однотактного процессора RISC-V (без поддержки команд загрузки/сохранения байт/полуслов)
2. Реализовать тракт данных с подключенным к нему устройством управления([#задание](#задание))
3. Подготовить программу по индивидуальному заданию и загрузить ее в память инструкций
4. Сравнить результат работы процессора на модели в **Vivado** и в симуляторе программы ассемблера

## Микроархитектура RISC-V

![Микроархитектура](../../../technical/Labs/Pic/uarch_dp.png)

## Задание

Реализовать процессор архитектуры RISC-V по предложенной микроархитектуре. Проверить работу процессора с помощью программы, написанной на ассемблере RISC-V по индивидуальному заданию, которое использовалось для написания программы для процессора архитектуры CYBERcobra.

### Как инициализировать память инструкций новой программой

Поскольку теперь ваш процессор почти полностью соответствует спецификации RISC-V, вы можете пользоваться существующими компиляторами, а значит, теперь для написании программы можно воспользоваться языком ассемблера RISC-V (помните, что пока вы не поддерживаете инструкции `lh`, `lhu`, `lb`, `lbu`, `sh`, `sb`).

Обычно ассемблеры выдают код собранной программы в виде шестнадцатеричных строк. При записи программы в файл инициализации, вы должны убрать префикс `0x`, если таковой имеется, поскольку системная функция инициализации памяти `$readmemh` и так уже настроена читать в шестнадцатеричном формате.

Кроме того, поскольку каждая ячейка памяти занимает 8 бит, необходимо разбить строки инструкции на отдельные байты. Более того, после того как вы это сделаете, нарушится порядок байт. Если инструкция была записана целиком и мы бы читали ее в одну 32-битную ячейку, проблем бы не было: допустим у нас есть инструкции `0xdeadc3b7` и `0xeaf38393`. В памяти со структурой, представленной ниже, они бы разместились следующим образом:

```text
----- 0 слово  ----|----- 1 слово -----
|[de][ad][c3][b7]| | |[ea][f3][83][93]|
|  3   2   1   0   |    4   3   2   1 |
|            нумерация байт           |
```

Слова нумеруются слева на право от младшего к старшему, однако разряды считаются наоборот: слева-направо от младшего к старшему. Когда используем побайтовую память, отдельные байты считаются так же как раньше считались слова, однако после разделения переносами (или пробелами), они будут расставлены не в том порядке (смотрите нумерацию байт внизу примера). Таким образом, нам необходимо обратить порядок байт.

Для данных инструкций, содержимое файла, инициализирующего память инструкций, должно принять следующий вид:

```text
b7 c3 ad de
93 83 f3 ea
```

Современные текстовые редакторы поддерживают режим множественных курсоров, что позволяет довольно быстро выполнить данную процедуру.

<details>
<summary> Пример такого редактирования </summary>
В VSCode дополнительные курсоры создаются либо через `alt+ЛКМ`, либо через `alt+ctrl+UP`, `alt+ctrl+DOWN`. Vivado так же поддерживает множественные курсоры (проведя мышью с зажатой ЛКМ вдоль нужных строк при зажатой клавише `Ctrl`).

![Пример создания и использования множественных курсоров](../../../technical/Other/Pic/multicursor_edit_example.gif)

</details>

Напишем простую программу, которая использует все типы инструкций для проверки нашего процессора. Сначала напишем программу на ассемблере:

```assembly
  addi  x1,  x0, 0x75С
  addi  x2,  x0, 0x8A7
  add   x3,  x1, x2
  and   x4,  x1, x2
  sub   x5,  x4, x3
  illegal instruction
  slli  x7,  x5, 1
  sw    x1,  0x0(x5)
  lw    x8,  0x0(x5)
  lui   x9,  0xFFF80
  auipc x10, 0x00004
  bne   x3,  x4, 0x04
  jal   x11, 0x00004
  jalr  x12, 0x0(x11)
```

Теперь в соответствии с кодировкой инструкций переведем программу в машинные коды:

```text
  011101011100  00000 000 00001 0010011
  100010100111  00000 000 00010 0010011
  0000000 00001 00010 000 00011 0110011
  0000000 00001 00010 111 00100 0110011
  0100000 00011 00100 000 00101 0110011
  0100000 00001 00101 001 00110 0010011
  0000000 00001 00101 001 00111 0010011
  0000000 00001 00101 010 00000 0100011
  000000000000  00101 010 01000 0000011
  11111111111110000000    01001 0110111
  00000000000000000100    01010 0010111
  0000000 00011 00100 001 00100 1100011
  00000000010000000000    01011 1101111
  000000000000  01011 000 01100 1100111
```

Полученную программу можно помещать в память программ и выполнять на процессоре.

## Порядок выполнения задания

1. Внимательно ознакомьтесь микроархитектурной реализацией. В случае возникновения вопросов, проконсультируйтесь с преподавателем.
2. Реализуйте модуль `riscv_dp`. Для этого:
   1. В `Design Sources` проекта с предыдущих лаб, создайте `Verilog`-файл `riscv_dp.v`.
   2. Опишите в нем модуль процессор riscv_dp с таким же именем и портами, как указано в [задании](#задание).
      1. Процесс реализации модуля очень похож на процесс описания модуля cybercobra, однако теперь появляется:
         1. декодер
         2. дополнительные мультиплексоры и знакорасширители.
   3. В этом же файле, либо в новом созданном опишите подключение созданного модуля тракта данных с памятью инструкций и данных. (При описании этого модуля используйте имена проводов `instr_addr` и `instr` для подключения памяти инструкций, это понадобится для правильной работы модуля верхнего уровня)
3. После описания модуля, его необходимо проверить с помощью [`тестового окружения`](../../Other/Testbench.md).
   1. Тестовое окружение находится [`здесь`](tb_riscv_dp.v).
   2. Программа, которой необходимо проинициализировать память инструкций находится [`здесь`](example.txt).
   3. Для запуска симуляции воспользуйтесь [`этой инструкцией`](../../Other/Vivado%20Basics/Run%20Simulation.md).
   4. Перед запуском симуляции убедитесь, что выбран правильный модуль верхнего уровня.
   5. **Во время симуляции убедитесь, что в логе есть сообщение о завершении теста!**
   6. Вполне возможно, что после первого запуска вы столкнетесь с сообщениями о множестве ошибок. Вам необходимо [исследовать](../../Other/Vivado%20Basics/Debug_manual.md) эти ошибки на временной диаграмме и исправить их в вашем модуле.
4. Добавьте в проект модуль верхнего уровня ([nexys_riscv_dp.v](board%20files/nexys_decoder.v)), соединяющий основной ваш процессор с периферией в ПЛИС. Описание работы модуля находится [здесь](board%20files).
5. Подключите к проекту файл ограничений ([nexys_a7_100t.xdc](board%20files/nexys_a7_100t.xdc)), если тот еще не был подключен, либо замените его содержимое данными из файла к этой лабораторной работе.
6. Проверьте работу процессора в ПЛИС.

---

<details>
  <summary>Прочти меня, когда выполнишь.</summary>
  Поздравляю, ты сделал(а) свой первый взрослый процессор! Теперь ты можешь говорить:

 >Я способен(на) на всё! Я сам(а) полностью, с нуля, сделал(а) процессор с архитектурой RISC-V! Что? Не знаешь, что такое архитектура? Пф, щегол! Подрастешь – узнаешь

</details>
