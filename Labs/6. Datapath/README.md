# Лабораторная работа 4 "Тракт данных"

Микроархитектуру можно разделить на две части: тракт данных и устройство управления. По тракту данных перемещаются данные (из памяти инструкций, регистрового файла, АЛУ, памяти данных, мультиплексоров), а устройство управления (основной дешифратор команд) получает текущую инструкцию из тракта и в ответ говорит ему как именно выполнить эту инструкцию, то есть управляет тем, как эти данные будут через тракт данных проходить.

## Цель

Описать на языке **Verilog** процессор с архитектурой **RISC-V**, реализовав его тракт данных, использую ранее разработанные блоки, и подключив к нему устройство управления. В рамках этого трека лабораторных работ требуется реализовать только поддержку обработки слов (то есть БЕЗ инструкций связанных с байтами и полусловами: `lh`, `lhu`, `lb`, `lbu`, `sh`, `sb`).

## Ход работы

1. Изучить микроархитектурную реализацию однотактного процессора RISC-V (без поддержки команд загрузки/сохранения байт/полуслов)
2. Реализовать тракт данных с подключенным к нему устройством управления([#задание](#задание))
3. Подготовить программу по индивидуальному заданию и загрузить ее в память инструкций
4. Сравнить результат работы процессора на модели в **Vivado** и в симуляторе программы ассемблера

## Микроархитектура RISC-V

![Микроархитектура](../../../technical/Labs/Pic/uarch_dp.png)

## Задание

Реализовать процессор архитектуры RISC-V по предложенной микроархитектуре. Проверить работу процессора с помощью программы, написанной на ассемблере RISC-V по индивидуальному заданию, которое использовалось для написания программы для процессора архитектуры CYBERcobra.

### Как инициализировать память инструкций новой программой

Поскольку теперь ваш процессор почти полностью соответствует спецификации RISC-V, вы можете пользоваться существующими компиляторами, а значит, теперь для написании программы можно воспользоваться языком ассемблера RISC-V (помните, что пока вы не поддерживаете инструкции `lh`, `lhu`, `lb`, `lbu`, `sh`, `sb`).

Обычно ассемблеры выдают код собранной программы в виде шестнадцатеричных строк. При записи программы в файл инициализации, вы должны убрать префикс `0x`, если таковой имеется, поскольку системная функция инициализации памяти `$readmemh` и так уже настроена читать в шестнадцатеричном формате.

Кроме того, поскольку каждая ячейка памяти занимает 8 бит, необходимо разбить строки инструкции на отдельные байты. Более того, после того как вы это сделаете, нарушится порядок байт. Если инструкция была записана целиком и мы бы читали ее в одну 32-битную ячейку, проблем бы не было: допустим у нас есть инструкции `0xdeadc3b7` и `0xeaf38393`. В памяти со структурой, представленной ниже, они бы разместились следующим образом:

```text
----- 0 слово  ----|----- 1 слово -----
|[de][ad][c3][b7]| | |[ea][f3][83][93]|
|  3   2   1   0   |    4   3   2   1 |
|            нумерация байт           |
```

Слова нумеруются слева на право от младшего к старшему, однако разряды считаются наоборот: слева-направо от младшего к старшему. Когда используем побайтовую память, отдельные байты считаются так же как раньше считались слова, однако после разделения переносами (или пробелами), они будут расставлены не в том порядке (смотрите нумерацию байт внизу примера). Таким образом, нам необходимо обратить порядок байт.

Для данных инструкций, содержимое файла, инициализирующего память инструкций, должно принять следующий вид:

```text
b7 c3 ad de
93 83 f3 ea
```

Современные текстовые редакторы поддерживают режим множественных курсоров, что позволяет довольно быстро выполнить данную процедуру.

<details>
<summary> Пример такого редактирования </summary>
В VSCode дополнительные курсоры создаются либо через `alt+ЛКМ`, либо через `alt+ctrl+UP`, `alt+ctrl+DOWN`. Vivado так же поддерживает множественные курсоры (проведя мышью с зажатой ЛКМ вдоль нужных строк при зажатой клавише `Ctrl`).

![Пример создания и использования множественных курсоров](../../../technical/Other/Pic/multicursor_edit_example.gif)

</details>

## Порядок выполнения задания

1. Внимательно ознакомьтесь микроархитектурной реализацией. В случае возникновения вопросов, проконсультируйтесь с преподавателем.
2. Реализуйте модуль `riscv_dp`. Для этого:
   1. В `Design Sources` проекта с предыдущих лаб, создайте `Verilog`-файл `riscv_dp.v`.
   2. Опишите в нем модуль процессор riscv_dp с таким же именем и портами, как указано в [задании](#задание).
      1. Процесс реализации модуля очень похож на процесс описания модуля cybercobra, однако теперь появляется:
         1. память данных
         2. декодер
         3. дополнительные мультиплексоры и знакорасширители.
3. После описания модуля, его необходимо проверить с помощью [`тестового окружения`](../../Other/Testbench.md).
   1. Тестовое окружение находится [`здесь`](tb_riscv_dp.v).
   2. Для запуска симуляции воспользуйтесь [`этой инструкцией`](../../Other/Vivado%20Basics/Run%20Simulation.md).
   3. Перед запуском симуляции убедитесь, что выбран правильный модуль верхнего уровня.
   4. **Во время симуляции, вы должны прожать "Run All" и убедиться, что в логе есть сообщение о завершении теста!**
   5. Вполне возможно, что после первого запуска вы столкнетесь с сообщениями о множестве ошибок. Вам необходимо [исследовать](../../Other/Vivado%20Basics/Debug_manual.md) эти ошибки на временной диаграмме и исправить их в вашем модуле.
4. Добавьте в проект модуль верхнего уровня ([nexys_riscv_dp.v](board%20files/nexys_decoder.v)), соединяющий основной ваш процессор с периферией в ПЛИС. Описание работы модуля находится [здесь](board%20files).
5. Подключите к проекту файл ограничений ([nexys_a7_100t.xdc](board%20files/nexys_a7_100t.xdc)), если тот еще не был подключен, либо замените его содержимое данными из файла к этой лабораторной работе.
6. Проверьте работу процессора в ПЛИС.

---

<details>
  <summary>Прочти меня, когда выполнишь.</summary>
  Поздравляю, ты сделал(а) свой первый взрослый процессор! Теперь ты можешь говорить:

 >Я способен(на) на всё! Я сам(а) полностью, с нуля, сделал(а) процессор с архитектурой RISC-V! Что? Не знаешь, что такое архитектура? Пф, щегол! Подрастешь – узнаешь

</details>
