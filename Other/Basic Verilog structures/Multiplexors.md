# Описание мультиплексора на языке Verilog

**Мультипле́ксор** — устройство, имеющее **несколько сигнальных входов**, **один или более управляющих входов** и **один выход**. Мультиплексор позволяет передавать сигнал **с одного из входов на выход**; при этом выбор желаемого входа осуществляется подачей соответствующей комбинации управляющих сигналов.

Иными словами, мультиплексор — это переключатель (коммутатор), соединяющий выход с одним из множества входов.

![../../../technical/Other/Basic%20Verilog%20structures/Pic/multiplexor/fig_01.drawio.png](../../../technical/Other/Basic%20Verilog%20structures/Pic/multiplexors/fig_01.drawio.png)

Для начала создадим простой двухвходовой мультиплексор. Предположим, на `Y` нам необходимо передать один из сигналов — `D0` или `D1` в зависимости от значения управляющего сигнала `S`: когда `S==0`, на `Y` подается сигнал `D0`, в противном случае — `D1`.

![../../../technical/Other/Basic%20Verilog%20structures/Pic/multiplexors/fig_02.drawio.png](../../../technical/Other/Basic%20Verilog%20structures/Pic/multiplexors/fig_02.drawio.png)

На языке Verilog это можно описать несколькими способами. Первый — с помощью **[тернарного условного оператора](https://ru.wikipedia.org/wiki/Тернарная_условная_операция)**:

<details>

## Тернарный условный оператор

<summary>О тернарном условном операторе</summary>

Операторы бывают различной **[арности](https://ru.wikipedia.org/wiki/Арность)**(количества аргументов оператора[операндов]):

- унарный (с одним операндом), пример: `-a`;
- бинарный (с двумя операндами), пример: `a+b`;
- тернарный (с тремя операндами), пример: `cond ? if_true : false`;
- и др.

Несмотря на то, что тернарным оператором может быть любой оператор, принимающий три операнда, обычно под ним подразумевается **тернарный условный оператор**, работающий следующим образом:

```text
<условие> ? <значение_если_условие_истинно> : <значение_если_условие_ложно>
```

Первым операндом идет некоторое условие (любое выражение, которое может быть сведено к 1 или 0). Далее ставится знак вопроса (часть тернарного оператора, отделяющая выражение первого операнда от выражения второго операнда). Далее пишется выражение, которое будет результатом тернарного условного оператора в случае, если условие оказалось истинным. После чего ставится двоеточие (часть тернарного условного оператора, отделяющая выражение второго операнда от выражения третьего операнда). Затем пишется выражение, которое будет результатом тернарного условного оператора в случае, если условие оказалось ложным.

Пример для языка C++:

```c++
a = b+c >= 5 ? b+c : b+d;
```

Сперва вычисляется первый операнд (выражение `b+c >= 5`). Если это выражение оказалось истинным (равно единице), то переменной `a` будет присвоено значение второго операнда (выражения `b+c`), в противном случае переменной `a` будет присвоено значение третьего операнда (выражения `b+d`).
</details>

```Verilog
wire Y;
assign Y = S==1 ? D1 : D0;
```

Данное выражение говорит нам, что если `S==1`, то `Y` присваивается значение `D1`, в противном случае — значение `D0`.

![../../../technical/Other/Basic%20Verilog%20structures/Pic/multiplexors/fig_03.drawio.png](../../../technical/Other/Basic%20Verilog%20structures/Pic/multiplexors/fig_03.drawio.png)

Также мультиплексор можно описать через конструкцию `if-else` в блоке `always`.

## Блок if-else

> Далее будет идти три очень важных абзаца сложного для понимания текста, очень важно запомнить что там написано и разобрать приведенный после них листинг.

<br><br>

---

### Блок always

Блок `always` — это специальный блок, который позволяет описывать комбинационные и последовательностные схемы, используя более сложные конструкции, такие как `if-else`, `case`. Что именно будет синтезировано зависит от того, что было написано в круглых скобках после символа `@`.

Поскольку результатом описания может быть как чисто комбинационная схема, так и схема, содержащая регистр, **ВСЕ СИГНАЛЫ, которым происходит присваивание в блоке always должны быть объявлены с типом reg**. В процессе синтеза, САПР сам поймет, нужно ли создавать регистры для этой схемы, или нет.

Кроме того, при присваивании внутри блока `always` используйте специальный оператор **неблокирующего присваивания** `<=`. Бывает еще оператор **блокирующего присваивания** `=`, объяснение различий в этих операторах требует отдельного документа, поэтому на текущий момент, во избежание проблем в будущем просто запомните: **внутри блока always необходимо использовать только оператор неблокирующего присваивания <=**.

```Verilog
reg Y;            // 1) В блоке always можно присваивать только сигналам,
                  //    объявленным с типом reg.
always @(*) begin // 2) Символ '*' говорит синтезатору создать
                  // комбинационную схему.
  if(S) begin     // 3) if-else может находиться только внутри блока always.
    Y <= D1;      // 4) Используется оператор неблокирующего присваивания.
  end else begin
    Y <= D0;
  end
end
```

---

> Остановитесь на выделенном выше фрагменте документа, пока полностью не разберете его. Без освоения всех описанных выше особенностей языка Verilog вы столкнетесь в будущем с множеством ошибок.

<br><br>

## case-блок

Мультиплексор также можно описать с использованием **конструкции case**.
Конструкция `case` представляет собой инструмент множественного ветвления, который сравнивает значение заданного выражения с множеством вариантов, и, в случае первого совпадения, использует соответствующую ветвь. На случай, если ни один из вариантов не совпадет с заданным выражением, конструкция `case` поддерживает вариант `default`. Данная конструкция визуально похожа на оператор `switch-case` в Си, однако вы должны понимать, что используется она не для написания программы, а описания аппаратуры, в частности **мультиплексоров**/**демультиплексоров** и **дешифраторов**.

**Конструкция `case`, наряду с `if-else`, может быть описана только в блоке `always`**.

Реализация двухвходового мультиплексора с помощью `case` может выглядеть так:

```Verilog
reg Y;
always @(*) begin
  case(S)           // Описываем блок case, где значение сигнала S
                    // будет сравниваться с различными возможными его значениями
    1'b0: Y <= D0;  // Если S==0, то Y = D0
    1'b1: Y <= D1;
  endcase           // Каждый case должен заканчиваться endcase
end                 // (так же как каждый begin должен оканчиваться end)
```

Рассмотрим вариант посложнее и опишем следующую схему:

![../../../technical/Other/Basic%20Verilog%20structures/Pic/multiplexors/fig_04.drawio.png](../../../technical/Other/Basic%20Verilog%20structures/Pic/multiplexors/fig_04.drawio.png)

Здесь уже используется мультиплексор 4-to-1. Управляющий сигнал `S` в данном случае двухбитный. В блоке case мы перечисляем всевозможные варианты значений `S` и описываем выход мультиплексора.

```Verilog
module case_mux_ex(
  input        A,
  input        B,
  input        C,
  input        D,
  input [2:0]  S,

  output reg   Y

);
  always @(*) begin
    case(S)
      3'b00:   Y <= A;
      3'b01:   Y <= C | B;      // в блоке case можно мультиплексировать
                                // не только провода, но и логические выражения
      3'b10:   Y <= (C|B) & D;
      /*
        Обратите внимание, что разрядность сигнала S — 3 бита.
        Это означает, что есть 8 комбинаций его разрядов.
        Выше было описано только 3 комбинации из 8.
        Если для всех остальных комбинаций на выходе мультиплексора должно
        быть какое-то одно значение "по умолчанию", используется специальная
        комбинация "default":
      */
      default: Y <= D;
    endcase
  end
endmodule
```

## Итоги

1. Мультиплексор — это **комбинационный** блок, подающий на выход один из нескольких входных сигналов.
2. Мультиплексор можно описать множеством способов, среди них:
   1. Использование [тернарного условного оператора](#тернарный-условный-оператор) через непрерывное присваивание;
   2. Использование конструкции [`if-else`](#блок-if-else) внутри блока `always`;
   3. Использование конструкции [`case`](#case-блок) внутри блока always (при этом стоит помнить, что через `case` можно описывать не только мультиплексоры).
3. Конструкции `if-else` и `case` в рамках данных лабораторных работ можно описывать только внутри блока [`always`](#блок-always). При работе с этим блоком необходимо помнить следующие особенности:
   1. Внутри блока always следует использовать оператор неблокирующего присваивания `<=`;
   2. Присваивать внутри блока `always` можно только сигналам, объявленным с типом `reg`.

---

## Проверь себя

Как, по-вашему, описать на языке Verilog схему, приведённую ниже?

![../../../technical/Other/Basic%20Verilog%20structures/Pic/multiplexors/fig_04.drawio.png](../../../technical/Other/Basic%20Verilog%20structures/Pic/multiplexors/fig_04.drawio.png)
