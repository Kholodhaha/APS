# Индивидуальные задания для программирования на языке ассемблера RISC-V

[`СОДЕРЖАНИЕ`](../README.md)

**Язык ассемблера** – это язык программирования низкого уровня, в котором машинные инструкции записываются в виде понятных человеку мнемоник.

**Ассемблер** – это программа, которая преобразует код, написанный на языке ассемблера в последовательность машинных инструкций.

После лекций о архитектуре RISC-V, каждый студент получает от преподавателя по лабораторным работам индивидуально задание – написать программу на языке ассемблера RISC-V. Эта же программа будет использоваться при тестировании разработанного процессора с архитектурой RISC-V (лабораторная работа 4). Результат вычисления разработанного процессора сравнивается с результатом симуляции в ассемблере. Если результаты совпадают, то будем полагать, что процессор работает правильно.

При выполнении задания необходимо использовать только стандартный набор целочисленных инструкций RV32I, то есть из арифметических операций, например, есть только сложение и вычитание. Более подробно о [`RV32I`](../Other/rv32i.md). Так же этот набор команд разбирается в [`лекции 6`](../Lectures/06.%20RISC-V%20architecture.md) и [`лекции 7`](../Lectures/07.%20RISC-V%20programming.md).


## Ассемблеры

Существует большое множество различных ассемблеров RISC-V, ты можешь выбрать тот, который больше понравится, не обязательно из списка. Основное их отличие – интерфейс и платформа, на которой он может быть запущен. Вот небольшой список на выбор:
1. [Venus](https://www.kvakil.me/venus/) - самый простой и быстрый путь, это онлайн-ассемблер. Зашел на сайт, написал код, нажал `Simulator` и готово. Можно выполнять по инструкции или сразу всю программу. Можно следить за содержимым регистров и памяти. Так же есть кнопка `Dump`, по нажатию на которую внизу отобразится машинный код в 16-ричных цифрах. Это понадобится, когда будешь готовить программу для своего процессора.
2. Venus VSCode - от тех же ребят плагин для VSCode. Чтобы им воспользоваться ставим [VSCode](https://code.visualstudio.com/download), а потом во вкладке плагинов ищем и добавляем "RISC-V Venus Simulator", дальше, надеюсь, разберешься.
3. [Jupiter](https://github.com/andrescv/jupiter) - запускается на любых платформах, нужно только, чтоб компьютер был одним из 3 млрд. устройств, на которых установлена [Java-машина](https://www.java.com/ru/download/ie_manual.jsp?locale=ru).
4. [Ripse](https://github.com/mortbopet/Ripes) - супер-классный инструмент, которым очень полезен и нагляден при изучении кэш-памяти. Круче остальных пунктов потому, что тут отрисована микроархитектура и для однотактного и для конвейерного процессора, можно смотреть как данные прыгают между блоками – красота! Релиз-версия находится [тут](https://github.com/mortbopet/Ripes/releases)
5. [RARS](https://github.com/TheThirdOne/rars) - еще один инструмент, тоже отрисована микроархитектура, но написан на Java, поэтому не должно быть проблем с запуском на любой операционной системе. Надо только [Java-машину](https://www.java.com/ru/download/ie_manual.jsp?locale=ru) поставить, конечно же. Еще **ОБРАТИ ВНИМАНИЕ** он умеет работать с инструкциями для CSR, которые используются в прерываниях. Скачиваем [тут](https://github.com/TheThirdOne/rars/releases/tag/continuous)


## Про ввод и вывод данных

Для ввода чисел необходимо использовать инструкции загрузки константы, например, если вам необходимо ввести два числа 5 и 8, то их можно разместить, к примеру, в регистрах x2 и x3 следующим образом:

``` assembly risc-v
li x2, 5
li x3, 8
```

Во время сдачи работы необходимо сказать преподавателю в каких регистрах размещаются входные данные и в каком регистре, или регистрах, можно посмотреть результат (вывод) после выполнения программы.

В заданиях с массивами, при проверке на процессоре, данные заранее помещаются в память данных (Data Memory) используя `$readmemh()`.


## Задания

> Номер варианта берется у преподавателя лабораторных работ.
>
> Все вводимые числа 32-битные (потому что в RV32I используются 32-битные операнды). В примерах заданий используются не 32-битные числа только потому, что они очень длинные для записи в двоичном виде здесь. В решениях же должны использоваться 32-битные числа! И не забывай, что все числа в компьютере представляются в двоичном виде. Когда ты пишешь `li x2, 5` в процессор попадает 101, а не 5. Десятичные цифры используются для удобства человека, а компьютер их не понимает.

1. Вводится два целых числа, необходимо написать программу, которая их перемножает;
2. Вводится два целых числа, требуется вычислить целочисленный результат деления;
3. Вводится два целых числа, необходимо вычислить остаток от деления;
4. Вводится два числа – A и B. Требуется [циклически сдвинуть](https://ru.wikipedia.org/wiki/Битовый_сдвиг#Циклический_сдвиг) число A влево на B бит;
5. Вводится два числа – A и B. Требуется [циклически сдвинуть](https://ru.wikipedia.org/wiki/Битовый_сдвиг#Циклический_сдвиг) число A вправо на B бит;
6. Вводится число, необходимо перевернуть его наоборот (пример для 4 бит: 1100 -> 0011);
7. Вводится первый элемент арифметической прогрессии, шаг прогрессии и номер элемента n. Необходимо вывести n-ый член этой прогрессии;
8. Вводится число, если оно делится нацело на 3, 5 или 7, то вывести 1, в противном случае 0;
9. Вводится число, необходимо сформировать из него два числа: одно состоящее из четных битов вводимого, второе – из нечетных. Например, вводится 42 (101010), значит на выходе будет 7 (111) и 0 (000);
10. Вводится число, необходимо вывести 1, если в двоичном представлении числа есть ровно 3 подряд идущие единицы;
11. Вводится два числа, выводить количество бит, в которых эти числа совпадают. Например, вводится 12 (01100) и 21 (10101), у них совпадают только биты на позициях 1 и 2 (счет с нуля начинается), значит ответ будет 2 бита;
12. Вводится два числа – A и B. Выводится такое же число, но старшие B единиц числа A заменяются на 0;
13. Вводится два числа, необходимо найти их наибольший общий делитель;
14. Возвести введенное число в квадрат;
15. Вводится число, требуется посчитать в нем количество единиц и нулей и выдать модуль их разности. 8-битный пример – вводится 128 (10000000), тут 7 нулей и 1 единица, значит выводится |1 - 7| = 6;
16. Вводится число, требуется посчитать его факториал;
17. Вводится два подготовленных числа в [двоично-десятичном коде](https://ru.wikipedia.org/wiki/Двоично-десятичный_код), требуется получить их сумму в двоичном виде;
18. Рассчитать площадь круга при заданном радиусе с точностью до целого;
19. Вводится число, необходимо найти большую цифру десятичного представления этого числа. Например, вводится 256, значит на выходе 6;
20. В памяти размещается массив, необходимо произвести его сортировку, при этом выкинув все нечетные числа;
21. Вводится число n. Требуется посчитать сумму четных элементов ряда Фибоначчи до элемента номер n;
22. Вводится число, требуется вывести ближайший к нему элемент ряда Фибоначчи. Ближайший с обоих сторон;
23. Вывести 1, если вводимое число является простым;
24. Найти и удалить в массиве повторяющиеся числа;
25. Вводится месяц и день этого года, требуется вывести день недели;
26. Перевернуть введенное число в десятичном формате наоборот. Например, вводится 12, значит выводится 21;
27. Вводится число, необходимо найти сумму всех его делителей;
28. Объявляется массив, требуется найти сумму двух его максимальных и двух минимальных элементов (сумма четырех элементов массива);
29. Найти и вывести [медиану](https://ru.wikipedia.org/wiki/Медиана_(статистика)) в объявленном массиве;
30. Вводится число, требуется найти сумму его десятичных цифр. Например, вводится 256, значит на выходе 2+5+6 = 13.


## Задачи немного повышенной сложности

1. Найти квадратный корень числа, полагая, что младшие 8 бит числа находятся после фиксированной запятой (0 1000 0000 без точки - это 128, 0.1000 0000 с точкой – это 0.5);
2. Посчитать синус для заданного угла, полагая, что младшие 8 бит числа находятся после фиксированной запятой (0 1000 0000 без точки - это 128, 0.1000 0000 с точкой – это 0.5);
3. Сложить два подготовленных числа в формате IEEE754;
4. Перемножить два подготовленных числа в формате IEEE754;
5. Найти и удалить в массиве повторяющиеся числа, при этом пустых мест между элементами остаться не должно, данные в массиве надо будет "подвинуть".
